 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/

#include "TransAngles.h"
 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooBkgAngle.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 


 ClassImp(RooBkgAngle) 
         
  RooBkgAngle::RooBkgAngle(const char *name, const char *title,
        RooRealVar &cpsi, RooRealVar &ctheta, RooRealVar &phi,
        RooRealVar& B1, RooRealVar& B2, RooRealVar& B3,
        RooRealVar& B4, RooRealVar& B5, RooRealVar& B6,
        Efficiency *efficiency, Bool_t fit) :
   RooAbsPdf(name,title),
   _angles(this,cpsi,ctheta,phi),
   _B1("_B1","B1",this,B1),
   _B2("_B2","B2",this,B2),
   _B3("_B3","B3",this,B3),
   _B4("_B4","B4",this,B4),
   _B5("_B5","B5",this,B5),
   _B6("_B6","B6",this,B6)
{
    _efficiency = efficiency;
    if (_efficiency)
        _fit = fit;
    else 
        _fit = kFALSE;
 } 

 RooBkgAngle::RooBkgAngle(const RooBkgAngle& other, const char* name) :  
   RooAbsPdf(other,name), 
   _angles(this,other._angles),
   _B1("_B1",this,other._B1),
   _B2("_B2",this,other._B2),
   _B3("_B3",this,other._B3),
   _B4("_B4",this,other._B4),
   _B5("_B5",this,other._B5),
   _B6("_B6",this,other._B6)
 {
    _fit = other._fit;
    _efficiency = other._efficiency;
 } 

 Double_t RooBkgAngle::evaluate() const {
    if (_fit)
        return (_B1 * _angles.f1() + _B2 * _angles.f2() + _B3 * _angles.f3()
            + _B4 * _angles.f4() + _B5 * _angles.f5() + _B6 * _angles.f6());
    else
        return (_B1 * _angles.f1() + _B2 * _angles.f2() + _B3 * _angles.f3()
            + _B4 * _angles.f4() + _B5 * _angles.f5() + _B6 * _angles.f6()) *
        _efficiency->getVal(_angles.cpsi(), _angles.ctheta(), _angles.phi());

 } 


 Int_t RooBkgAngle::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
  if (matchArgs(allVars, analVars, _angles.cpsiProxy(),_angles.cthetaProxy(),_angles.phiProxy())) return _angles.getIntegralCode(kTRUE , kTRUE , kTRUE );
  if (matchArgs(allVars, analVars,                     _angles.cthetaProxy(),_angles.phiProxy())) return _angles.getIntegralCode(kFALSE, kTRUE , kTRUE );
  if (matchArgs(allVars, analVars, _angles.cpsiProxy(),                      _angles.phiProxy())) return _angles.getIntegralCode(kTRUE , kFALSE, kTRUE );
  if (matchArgs(allVars, analVars, _angles.cpsiProxy(),_angles.cthetaProxy()                   )) return _angles.getIntegralCode(kTRUE , kTRUE , kFALSE);
  if (matchArgs(allVars, analVars, _angles.cpsiProxy()                                         )) return _angles.getIntegralCode(kTRUE , kFALSE, kFALSE);
  if (matchArgs(allVars, analVars,                     _angles.cthetaProxy()                   )) return _angles.getIntegralCode(kFALSE, kTRUE , kFALSE);
  if (matchArgs(allVars, analVars,                                           _angles.phiProxy())) return _angles.getIntegralCode(kFALSE, kFALSE, kTRUE );
  return 0 ; 
 } 



 Double_t RooBkgAngle::analyticalIntegral(Int_t code, const char* range) const  
{
     if(_efficiency)
        return ( _B1 * _efficiency->getPhi1() +
            _B2 * _efficiency->getPhi2() +
            _B3 * _efficiency->getPhi3() +
            _B4 * _efficiency->getPhi4() +
            _B5 * _efficiency->getPhi5() +
            _B6 * _efficiency->getPhi6() );
    else
        return ( _B1 * _angles.integralF1(code, range) +
            _B2 * _angles.integralF2(code, range) +
            _B3 * _angles.integralF3(code, range) +
            _B4 * _angles.integralF4(code, range) +
            _B5 * _angles.integralF5(code, range) +
            _B6 * _angles.integralF6(code, range));
 } 


 Int_t RooBkgAngle::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const 
 { 
   // LIST HERE OVER WHICH VARIABLES INTERNAL GENERATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE GENERATOR CONFIGURATION BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES. IF THE FLAG staticInitOK IS TRUE THEN IT IS SAFE TO PRECALCULATE 
   // INTERMEDIATE QUANTITIES IN initGenerator(), IF IT IS NOT SET THEN YOU SHOULD NOT ADVERTISE
   // ANY GENERATOR METHOD THAT RELIES ON PRECALCULATIONS IN initGenerator()

   // if (matchArgs(directVars,generateVars,x)) return 1 ;   
   return 0 ; 
 } 



 void RooBkgAngle::generateEvent(Int_t code) 
 { 
   // GENERATE SET OF OBSERVABLES DEFINED BY RETURN CODE ASSIGNED BY getGenerator()
   // RETURN THE GENERATED VALUES BY ASSIGNING THEM TO THE PROXY DATA MEMBERS THAT
   // REPRESENT THE CHOSEN OBSERVABLES

   // assert(code==1) ; 
   // x = 0 ; 
   return; 
 } 



