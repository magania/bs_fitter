 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/

#include "TransAngles.h"

 #include "Riostream.h" 
 #include <RooBkgAngle.h>
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 

templateClassImp(RooBkgAngle)

template<class TA, class TAI>
  RooBkgAngle<TA, TAI>::RooBkgAngle(const char *name, const char *title,
        RooRealVar &cpsi, RooRealVar &ctheta, RooRealVar &phi,
        RooRealVar& B1, RooRealVar& B2, RooRealVar& B3,
        RooRealVar& B4, RooRealVar& B5, RooRealVar& B6,
        TA &ta) :
   RooAbsPdf(name,title),
   _angles(this, cpsi, ctheta, phi, ta),
   _B1("_B1","B1",this,B1),
   _B2("_B2","B2",this,B2),
   _B3("_B3","B3",this,B3),
   _B4("_B4","B4",this,B4),
   _B5("_B5","B5",this,B5),
   _B6("_B6","B6",this,B6),
   _aleatorio(0)
{
} 

/*RooBkgAngle::RooBkgAngle(const char *name, const char *title,
        RooRealVar &cpsi, RooRealVar &ctheta, RooRealVar &phi,
        RooRealVar& B1, RooRealVar& B2, RooRealVar& B3,
        RooRealVar& B4, RooRealVar& B5, RooRealVar& B6,
        Phis phis) :
   RooAbsPdf(name,title),
   _B1("_B1","B1",this,B1),
   _B2("_B2","B2",this,B2),
   _B3("_B3","B3",this,B3),
   _B4("_B4","B4",this,B4),
   _B5("_B5","B5",this,B5),
   _B6("_B6","B6",this,B6),
   _use_phis(kTRUE)
{
    _angles = new TransAnglesPhis(this, cpsi, ctheta, phi, phis);
} */

template<class TA, class TAI>
 RooBkgAngle<TA, TAI>::RooBkgAngle(const RooBkgAngle& other, const char* name) :  
   RooAbsPdf(other,name),
   _angles(this, other._angles),
   _B1("_B1",this,other._B1),
   _B2("_B2",this,other._B2),
   _B3("_B3",this,other._B3),
   _B4("_B4",this,other._B4),
   _B5("_B5",this,other._B5),
   _B6("_B6",this,other._B6),
   _aleatorio(other._aleatorio)
{
}

template<class TA, class TAI>
Double_t RooBkgAngle<TA, TAI>::evaluate() const {
    return (_B1 * _angles.fe(1) + _B2 * _angles.fe(2) + _B3 * _angles.fe(3)
            + _B4 * _angles.fe(4) + _B5 * _angles.fe(5) + _B6 * _angles.fe(6));
 } 


template<class TA, class TAI>
 Int_t RooBkgAngle<TA, TAI>::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
  if (matchArgs(allVars, analVars, _angles.cpsiProxy(),_angles.cthetaProxy(),_angles.phiProxy())) return _angles.getIntegralCode(kTRUE , kTRUE , kTRUE );
  if (matchArgs(allVars, analVars,                     _angles.cthetaProxy(),_angles.phiProxy())) return _angles.getIntegralCode(kFALSE, kTRUE , kTRUE );
  if (matchArgs(allVars, analVars, _angles.cpsiProxy(),                      _angles.phiProxy())) return _angles.getIntegralCode(kTRUE , kFALSE, kTRUE );
  if (matchArgs(allVars, analVars, _angles.cpsiProxy(),_angles.cthetaProxy()                   )) return _angles.getIntegralCode(kTRUE , kTRUE , kFALSE);
  if (matchArgs(allVars, analVars, _angles.cpsiProxy()                                         )) return _angles.getIntegralCode(kTRUE , kFALSE, kFALSE);
  if (matchArgs(allVars, analVars,                     _angles.cthetaProxy()                   )) return _angles.getIntegralCode(kFALSE, kTRUE , kFALSE);
  if (matchArgs(allVars, analVars,                                           _angles.phiProxy())) return _angles.getIntegralCode(kFALSE, kFALSE, kTRUE );
  return 0 ; 
 } 


template<class TA, class TAI>
 Double_t RooBkgAngle<TA, TAI>::analyticalIntegral(Int_t code, const char* range) const  
 {
    return (_B1 * _angles.int_fe(1, code, range) +
            _B2 * _angles.int_fe(2, code, range) +
            _B3 * _angles.int_fe(3, code, range) +
            _B4 * _angles.int_fe(4, code, range) +
            _B5 * _angles.int_fe(5, code, range) +
            _B6 * _angles.int_fe(6, code, range));
 } 

template<class TA, class TAI>
 Int_t RooBkgAngle<TA, TAI>::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const 
 {
    if (matchArgs(directVars, generateVars, _angles.phiProxy(), _angles.cthetaProxy(), _angles.cpsiProxy())) return 1;
    return 0;
 } 


template<class TA, class TAI>
 void RooBkgAngle<TA,TAI>::generateEvent(Int_t code) 
{
    Double_t max = 4;
    Double_t value = 0;

    while (1) {
        _angles.cpsi(RooRandom::uniform(&_aleatorio) * (_angles.cpsiMax() - _angles.cpsiMin()) + _angles.cpsiMin());
        _angles.ctheta(RooRandom::uniform(&_aleatorio) * (_angles.cthetaMax() - _angles.cthetaMin()) + _angles.cthetaMin());
        _angles.phi(RooRandom::uniform(&_aleatorio) * (_angles.phiMax() - _angles.phiMin()) + _angles.phiMin());

        value = evaluate();

        if (value > max) {
            cout << "EE: Value > max " << value << endl;
            max = value * 1.05;
        }

        Double_t rand = RooRandom::uniform(&_aleatorio) * max;
        if (rand < value)
            break;
    }
 } 
